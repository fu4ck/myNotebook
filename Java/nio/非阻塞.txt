某时刻客户端给服务端发送了一些数据，阻塞I/O这时会调用read()方法阻塞地读取数据

而NIO的服务端会在selector中添加一个读事件。
服务端的处理线程会轮询地访问selector，如果访问selector时发现有感兴趣的事件到达，
则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。
反正不会为了read或者write而卡在那里
而且select()也是可以被wakeup()的