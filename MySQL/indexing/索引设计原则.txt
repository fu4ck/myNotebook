1） 搜索的索引列，不一定是要选择的列。最适合索引的列是出现在where子句中的列，或连接(join on)子句中指定的列，而不是出现在select关键字后选择列表中的列。 
2） 使用唯一索引。索引的列的基数越大，效果越好（建立索引列的数据要一定程度上不同）。例如，存放出生日期的列具有不同值，很容易区分各行。而用来记录性别的列，只有”M”和”F”，则对此列进行索引没有多大用处。 
3） 使用短索引。如果对字符串建立索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)的列，如果在前10或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10或20个字符建立索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘IO较少，较短的值比较起来更快。对于较短的键值，索引高速缓存中的块能容纳更多的键值，MySQL也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性。 
4） 利用最左前缀。在创建一个n列的索引时，实际是创建了多个索引(e.g.创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引)。多列索引可起到几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀。 
5） 不要过度使用索引。每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能。在修改表的内容时，索引必须进行更新，有时可能需要重构，因此，索引越多，所化的时间越长。 
6） 对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就按照唯一索引的顺序保存。既没有主键又没有唯一索引，表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或内部列进行访问是最快的，所以InnoDB表尽量自己指定主键，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键。InnoDB表的普通索引会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果。 


数据量小的表不需要建立索引(就像两三页的宣传手册，谁还会去看目录)
数据变更数据维护索引，更多的索引意味着更多维护成本
更多的索引意味着需要更多的空间 